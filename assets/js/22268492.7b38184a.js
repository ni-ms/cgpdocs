"use strict";(self.webpackChunkassignment_docs=self.webpackChunkassignment_docs||[]).push([[304],{3905:(e,t,i)=>{i.d(t,{Zo:()=>c,kt:()=>m});var a=i(7294);function r(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function o(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,a)}return i}function n(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?o(Object(i),!0).forEach((function(t){r(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):o(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function s(e,t){if(null==e)return{};var i,a,r=function(e,t){if(null==e)return{};var i,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)i=o[a],t.indexOf(i)>=0||(r[i]=e[i]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)i=o[a],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(r[i]=e[i])}return r}var l=a.createContext({}),h=function(e){var t=a.useContext(l),i=t;return e&&(i="function"==typeof e?e(t):n(n({},t),e)),i},c=function(e){var t=h(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var i=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=h(i),u=r,m=d["".concat(l,".").concat(u)]||d[u]||p[u]||o;return i?a.createElement(m,n(n({ref:t},c),{},{components:i})):a.createElement(m,n({ref:t},c))}));function m(e,t){var i=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=i.length,n=new Array(o);n[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,n[1]=s;for(var h=2;h<o;h++)n[h]=i[h];return a.createElement.apply(null,n)}return a.createElement.apply(null,i)}u.displayName="MDXCreateElement"},516:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>n,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>h});var a=i(7462),r=(i(7294),i(3905));const o={sidebar_position:4,sidebar_label:"Historical Implementations"},n="Historical Implementations",s={unversionedId:"hist",id:"hist",title:"Historical Implementations",description:"1) 1984, Goral et al.: Classical Radiosity",source:"@site/docs/hist.md",sourceDirName:".",slug:"/hist",permalink:"/ /cgpdocs/docs/hist",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,sidebar_label:"Historical Implementations"},sidebar:"tutorialSidebar",previous:{title:"Radiosity",permalink:"/ /cgpdocs/docs/radiosity"},next:{title:"Our Implementations",permalink:"/ /cgpdocs/docs/our"}},l={},h=[{value:"1) 1984, Goral et al.: Classical Radiosity",id:"1-1984-goral-et-al-classical-radiosity",level:3},{value:"2) 1988, Cohen et al.: Progressive Refinement Radiosity",id:"2-1988-cohen-et-al-progressive-refinement-radiosity",level:3},{value:"3) 1997, Keller: Instant Radiosity",id:"3-1997-keller-instant-radiosity",level:3},{value:"4) 2014, Mara et al.: Deep G-Buffer Based Approximate Radiosity",id:"4-2014-mara-et-al-deep-g-buffer-based-approximate-radiosity",level:3}],c={toc:h};function d(e){let{components:t,...i}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"historical-implementations"},"Historical Implementations"),(0,r.kt)("h3",{id:"1-1984-goral-et-al-classical-radiosity"},"1) 1984, Goral et al.: Classical Radiosity"),(0,r.kt)("p",null,"The original radiosity technique proposed solving the diffuse part of the rendering equation by solving an NxN matrix (where N = number of patches) of linear equations composed of the form factors and distributed energy of each patch. In order for this solution to work the surfaces in the scene had to be subdivided into smaller surfaces (aforementioned patches) whose form factors had to be determined. This was done by integrating over a hemisphere placed over the patch in question. This hemisphere represented everything a patch could see in the scene. The NxN matrix had to be then solved."),(0,r.kt)("p",null,"A patch essentially distributes its energy to all of the other patches visible to it. This had to be done for every patch and the final radiosity value was returned for every patch in the scene, which could be displayed on the screen. This method allowed scenes to be rendered with complex inter-object diffuse reflections. Color bleeding and soft shadows were observable. It is also view-independent. For a static scene the matrix only had to be solved once, after which the observer could freely fly around the scene without any further calculations."),(0,r.kt)("p",null,"The downside was the incredibly high initial computation costs \u2013 it was needed to produce, store and solve an NxN matrix so the complexity scaled quadratically with the number of patches. Using this method for dynamic scenes was hence out of the question."),(0,r.kt)("h3",{id:"2-1988-cohen-et-al-progressive-refinement-radiosity"},"2) 1988, Cohen et al.: Progressive Refinement Radiosity"),(0,r.kt)("p",null,"This new radiosity aimed to simplify the calculations that were present in classical radiosity. This was achieved by transforming the algorithm so that the form factors are computed \u201con-the-fly\u201d (as in, the scene was rendered and then progressively updated with new information). The form factor calculation was also changed, instead of the hemisphere method a hemicube was placed on the patch, reducing the number of visual artifacts (at least in OpenGL)."),(0,r.kt)("p",null,"Instead of the \u201cgathering\u201d approach used by Goral et al., where a patch first receives all the light from the visible patches, here a \u201cshooting\u201d method was used. One patch first distributes all its energy to the visible patches (\u201creceivers\u201d) and thus updates the radiosity values of multiple patches. If the shooters with the highest energy are chosen first, the solution converges quickly, since these patches contribute the most to the lighting of the scene. The second improvement is the introduction of the ambient term (essentially a rough guess of the ambient lighting in the scene). Hence the ambient term would try to give a rough approximation of the end result during the early stages of the algorithm and would fade out as the algorithm progresses, so instead of a dramatic change (going from a completely dark scene to a lit one) it would start with a unsophisticated lighting solution, which would then gradually switch to the radiosity-computed solution."),(0,r.kt)("p",null,"This is the approach that we are basing our implementation on."),(0,r.kt)("h3",{id:"3-1997-keller-instant-radiosity"},"3) 1997, Keller: Instant Radiosity"),(0,r.kt)("p",null,"This algorithm approximates diffuse and specular radiance by creating virtual point lights (VPLs) wherever a light ray hits an object. This VPL is going to emit light as if it was reflected from a given surface. For example, if a ray from a white light hits a green surface, a green VPL is created where the light ray hit the surface."),(0,r.kt)("h3",{id:"4-2014-mara-et-al-deep-g-buffer-based-approximate-radiosity"},"4) 2014, Mara et al.: Deep G-Buffer Based Approximate Radiosity"),(0,r.kt)("p",null,"This radiosity method is implemented with the help of the modern programmable geometry shaders on the GPU. Mara et al. also describe how to integrate this radiosity method with other global illumination methods (ray tracing) and ambient occlusion."))}d.isMDXComponent=!0}}]);