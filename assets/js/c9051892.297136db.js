"use strict";(self.webpackChunkassignment_docs=self.webpackChunkassignment_docs||[]).push([[277],{3905:(e,t,r)=>{r.d(t,{Zo:()=>d,kt:()=>f});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},d=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=l(r),p=a,f=h["".concat(c,".").concat(p)]||h[p]||u[p]||i;return r?n.createElement(f,o(o({ref:t},d),{},{components:r})):n.createElement(f,o({ref:t},d))}));function f(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[h]="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=r[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"},9370:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var n=r(7462),a=(r(7294),r(3905));const i={sidebar_position:3},o="Radiosity",s={unversionedId:"radiosity",id:"radiosity",title:"Radiosity",description:"Radiosity is a global illumination algorithm where every surface is assumed to be an ideal Lambertian surface, which means that every surface reflects light equally in all directions. This means that radiosity by itself cannot handle specular reflections and is thus not good for modeling glossy surfaces.",source:"@site/docs/radiosity.md",sourceDirName:".",slug:"/radiosity",permalink:"/docs/radiosity",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Definitions",permalink:"/docs/definition"},next:{title:"Historical Implementations",permalink:"/docs/hist"}},c={},l=[],d={toc:l};function h(e){let{components:t,...i}=e;return(0,a.kt)("wrapper",(0,n.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"radiosity"},"Radiosity"),(0,a.kt)("p",null,"Radiosity is a global illumination algorithm where every surface is assumed to be an ideal Lambertian surface, which means that every surface reflects light equally in all directions. This means that radiosity by itself cannot handle specular reflections and is thus not good for modeling glossy surfaces."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"img.png",src:r(589).Z,width:"376",height:"281"})),(0,a.kt)("p",null,"All the surfaces in a scene are first subdivided into smaller \u201cpatches\u201d. These patches then accumulate and store the amount of light arriving at them from all the light sources present, which is then going to be distributed back into the scene again. The energy stored in a patch is assumed to be uniform. The amount of energy transferred between the two patches depends on how much they \u2018see\u2019 each other and this measure is called the form factor between two patches."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"img_1.png",src:r(8690).Z,width:"622",height:"187"})),(0,a.kt)("p",null,"Where rxy is the vector from one patch to the other, \u03b8x and \u03b8y are the angles between rxy and the respective normal vector of the patches. dAx and dAy are the areas of the respective patches. V(x,y) is the visibility term."),(0,a.kt)("p",null,"What this leads to when executed over all the surfaces present is a (relatively) smoothly shaded scene with natural light bleeding between surfaces, since the energy they shoot back also takes into account their color. Soft shadows are also generated as a consequence without any additional computation as the regions of the shadow that should be softer get so due to the energy they receive back from the other surfaces."))}h.isMDXComponent=!0},589:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/img-063c55c9f2ac7bb9926e182c106f758e.png"},8690:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/img_1-d8a3a5b5f5a1ff145d13968d42dd8eb0.png"}}]);